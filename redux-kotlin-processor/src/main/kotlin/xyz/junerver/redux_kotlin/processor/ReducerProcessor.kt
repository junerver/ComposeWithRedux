package xyz.junerver.redux_kotlin.processor

import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo
import xyz.junerver.redux_kotlin.annotation.SliceReducer

/**
 * Description:
 * @author Junerver
 * date: 2022/8/16-9:28
 * Email: junerver@gmail.com
 * Version: v1.0
 */
class ReducerProcessor(environment: SymbolProcessorEnvironment) : SymbolProcessor {
    private val codeGenerator = environment.codeGenerator
    private val logger = environment.logger
    private val options = environment.options

    // 避免二次执行
    private var hadRun = false

    // 避免在不需要创建文件的模块创建文件
    private var isNeed = false
    override fun process(resolver: Resolver): List<KSAnnotated> {
        // 拿到全部注解的符号
        val symbols = resolver.getSymbolsWithAnnotation(SliceReducer::class.qualifiedName!!)
            .filter { it.validate() }
        // 用于返回的不需要处理的符号
        val ret = symbols.filter { !it.validate() }.toList()
        // 包名
        val packageName = options["target"] ?: ""
        // 在包名下创建文件
        val fileBuilder = FileSpec.builder(packageName, "ReduxKotlinRoot")
        // data class 作为AppState
        val classBuilder = TypeSpec.classBuilder("AppState").addModifiers(KModifier.DATA)
        // data class 的构造函数
        val ctorBuilder = FunSpec.constructorBuilder()
        // AppState 对应的ClassName
        val appStateClass = ClassName(packageName, "AppState")
        // 添加 rootReducer 函数
        val rootReducerBuilder = FunSpec.builder("rootReducer")
            .addParameter("state", appStateClass)
            .addParameter("action", Any::class)
            .returns(appStateClass)
                // T% 是 KotlinPoet 的一个特殊占位符用来表示类型
            .addCode("return %T(\n", appStateClass)

        // 用于AppState数据类增加成员属性、构造器参数，给rootReducer函数增加切片的各种星系
        fun addSliceInfo(
            // KotlinSymbol描述
            ksDeclaration: KSDeclaration,
            // 切片状态名称
            sliceStateName: String,
            // 切片状态类型
            sliceStateType: KSType
        ) {
            // 这是被注解的sliceReducer函数
            val sliceReducerFunc =
                MemberName(ksDeclaration.packageName.asString(), "$ksDeclaration")
            // 属性 = reducer函数，M% 是 KotlinPoet 的一个特殊占位符用来表示函数或者属性
            rootReducerBuilder.addCode(
                "   $sliceStateName = %M(state.$sliceStateName, action),\n",
                sliceReducerFunc
            )

            // AppState数据类的构造函数添加参数
            ctorBuilder.addParameter(sliceStateName, sliceStateType.toTypeName())
            // 这段代码会为构造函数增加val，这样构造器中的参数也是类的成员属性
            classBuilder.addProperty(
                PropertySpec.builder(sliceStateName, sliceStateType.toTypeName())
                    .initializer(sliceStateName)
                    .build()
            )
        }
        // 开始处理符号，判断是否为函数或者属性，这样可以兼容val函数
        symbols.filter { it is KSFunctionDeclaration || it is KSPropertyDeclaration }
            .filter { it.validate() }
                // 转换成KotlinSymbol描述，他是KSF/KSP的超类
            .map { it as KSDeclaration }
                // 队列转换成数组操作
            .toList()
            .forEach { funcDeclare ->
                isNeed = true
                // 拿到被注解目标的注解一个队列
                // 拿到我们自定义的注解获取到注解的参数，由于只有一个参数直接拿0
                val annArgument = funcDeclare.annotations.filter { ann ->
                    ann.shortName.asString() == SliceReducer::class.simpleName
                }.last().arguments[0]
                // 拿到注解参数声明的slice状态字段名称
                val sliceStateName = annArgument.value.toString()
                // 从函数中获取参数1，然后获得其类型，这是slice切片状态的类型
                val sliceStateType: KSType = if (funcDeclare is KSFunctionDeclaration) {
                    // 普通的 fun 函数获取参数类型
                    funcDeclare.parameters[0].type.resolve()
                } else {
                    // 麻烦一点的 val 函数获取参数类型
                    (funcDeclare as KSPropertyDeclaration).type.resolve().arguments[0].type!!.resolve()
                }
                // 调用函数，给AppState与rootReducer函数增加这些slice的信息
                addSliceInfo(funcDeclare, sliceStateName, sliceStateType)
            }
        if (!hadRun && isNeed) {
            // 遍历参数属性完毕，构造AppState数据类
            classBuilder.primaryConstructor(ctorBuilder.build())
            // 为rootReducer是一个单表达式函数，添加参数结束括号
            rootReducerBuilder.addCode(")")

            // 文件构造器添加文件注释
            fileBuilder.addFileComment("Generated by KSP")
                    // 添加AppState类型
                .addType(classBuilder.build())
                    // 添加rootReducer函数
                .addFunction(rootReducerBuilder.build())
            // 写文件
            fileBuilder.build().writeTo(codeGenerator, false)
            hadRun = true
        }
        return ret
    }


}