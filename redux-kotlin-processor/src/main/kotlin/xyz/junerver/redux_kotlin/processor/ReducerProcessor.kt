package xyz.junerver.redux_kotlin.processor

import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo
import xyz.junerver.redux_kotlin.annotation.SliceReducer

/**
 * Description:
 * @author Junerver
 * date: 2022/8/16-9:28
 * Email: junerver@gmail.com
 * Version: v1.0
 */
class ReducerProcessor(environment: SymbolProcessorEnvironment) : SymbolProcessor {
    private val codeGenerator = environment.codeGenerator
    private val logger = environment.logger
    private val options = environment.options

    // 避免二次执行
    var hadRun = false

    // 避免在不需要创建文件的模块创建文件
    var isNeed = false
    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(SliceReducer::class.qualifiedName!!)
            .filter { it.validate() }
        val ret = symbols.filter { !it.validate() }.toList()
        val packageName = options["target"] ?: ""
        val fileBuilder = FileSpec.builder(packageName, "ReduxKotlinRoot")
        // data class 作为AppState
        val classBuilder = TypeSpec.classBuilder("AppState").addModifiers(KModifier.DATA)
        val ctorBuilder = FunSpec.constructorBuilder()
        // 添加 rootReducer 函数
        val appStateClass = ClassName(packageName, "AppState")
        val rootReducerBuilder = FunSpec.builder("rootReducer")
            .addParameter("state", appStateClass)
            .addParameter("action", Any::class)
            .returns(appStateClass)
            .addCode("return %T(\n", appStateClass)

        fun addSliceInfo(
            ksDeclaration: KSDeclaration,
            sliceStateName: String,
            sliceStateType: KSType
        ) {
            val sliceReducerFunc =
                MemberName(ksDeclaration.packageName.asString(), "$ksDeclaration")

            rootReducerBuilder.addCode(
                "   $sliceStateName = %M(state.$sliceStateName, action),\n",
                sliceReducerFunc
            )

            // 构造函数添加参数
            ctorBuilder.addParameter(sliceStateName, sliceStateType.toTypeName())
            // 这段代码会为构造函数增加val
            classBuilder.addProperty(
                PropertySpec.builder(sliceStateName, sliceStateType.toTypeName())
                    .initializer(sliceStateName)
                    .build()
            )
        }

        symbols.filter { it is KSFunctionDeclaration || it is KSPropertyDeclaration }
            .filter { it.validate() }
            .map { it as KSDeclaration }
            .toList()
            .forEach { funcDeclare ->
                isNeed = true
                // 拿到被注解目标的注解一个队列
                // 拿到我们自定义的注解获取到注解的参数，由于只有一个参数直接拿0
                val annArgument = funcDeclare.annotations.filter { ann ->
                    ann.shortName.asString() == SliceReducer::class.simpleName
                }.last().arguments[0]
                // 拿到注解申明的字段名称
                val sliceStateName = annArgument.value.toString()
                // 从函数中获取参数1，然后获得其类型
                val sliceStateType: KSType = if (funcDeclare is KSFunctionDeclaration) {
                    funcDeclare.parameters[0].type.resolve()
                } else {
                    (funcDeclare as KSPropertyDeclaration).type.resolve().arguments[0].type!!.resolve()
                }
                addSliceInfo(funcDeclare, sliceStateName, sliceStateType)
            }
        if (!hadRun && isNeed) {
            // 遍历参数属性完毕
            classBuilder.primaryConstructor(ctorBuilder.build())
            rootReducerBuilder.addCode(")")

            fileBuilder.addFileComment("Generated by KSP")
                .addType(classBuilder.build())
                .addFunction(rootReducerBuilder.build())

            fileBuilder.build().writeTo(codeGenerator, false)
            hadRun = true
        }
        return ret
    }


}